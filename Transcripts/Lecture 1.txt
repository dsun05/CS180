All right, excellent. Okay, yeah, so welcome to CS180, everyone. This is an algorithms class. We're going to start by going over the syllabus first, and then we'll start talking about the first content of the course. So feel free at any point to interrupt and ask questions. You can ask it either by the chat or by unmuting yourself and asking the question. I prefer the latter because I might not see the chat immediately. So if you're able to just say something out loud, feel free to ask. Yeah, so after we talk about the core syllabus, then we can talk about if you guys have any questions about the policies of this course, we can also address those as well. So let me switch briefly to the syllabus. Okay. Okay, so, as you guys know, this class is algorithms class. We have two lovely teaching assistants, Parshon and Oliver. Parshon will be teaching discussion 1A, Oliver will be teaching discussion 1B. This class is entirely on Zoom, and this is, you know, due to students having various internships. So attendance will not be required, although I highly recommend that you attend a lecture because it's very useful to be able to ask questions and engage with the class. So there are, we'll talk about the exams a little bit later. So the course textbook is Algorithm Design. It's listed here. I highly recommend getting access to the textbook somehow. I don't really care how you get access to it. So if you figure out a way to read it, that's great. do whatever you need to do, but it's a very good textbook and we're going to be following along fairly closely to the textbook, so it's a very good resource to use. And as the course progresses, I will also keep a more updated list of, you know, what chapters will be covered when. So here we kind of have a loose, you know, chapter two, but as, you know, the course progresses, I will say specifically these are the textbook sections we have covered and where you should be reading along. Okay, so there's also grade scope. So there's a join code here for the grade scope for the class. All of the assignments will be sitting on grade scope. All the exams will be uploaded to grade scope. So basically your scores will be here on grade scope. And then afterwards at the end of the class, we'll take the scores from grade scope and put them on my UCLA. So any point in time, and Gradescope really holds all your actual grades. We also have a course Piazza. So this is what the Piazza looks like. So for this class, if you have any questions about course material or questions about things in the class, please post them on Piazza. If you have administrative concerns or personal issues with attendance or anything, then please send an email. So again, Piazza is for anything related to course content. Please send that there. it'll be easier for us to answer those questions and other people might have similar questions. You can also make private posts if you need to on P1000. Okay, so yeah, as I mentioned, the course will be held entirely on Zoom, including exams. This is again to help accommodate students who are doing internships or may not be here. All lectures will be recorded, and again, participation is not mandatory, but it's highly recommended. So please keep in mind that the course is only eight weeks instead of the usual 10 weeks. That means that some of the content will be cut. So the course will be a little bit shorter than usual. And it will be-- I'm not sure if it'll be more accelerated, but it is a shorter time period. And so you really do have to keep on track of things. This is actually quite a difficult course. So here's a tentative schedule, only eight weeks instead of 10. And this may get modified a little bit just due to the shorter length of the class. There's going to be one midterm and one final. So the midterm is going to be on Monday, week five from 8-- OK, so here's the times. So the midterm will be 8 to 10 PM on Monday of week five. And this will be held via Zoom. And the final exam will be 7 to 10 PM on Friday of week eight. So this is the last week of the class. It will be on the Friday. Both of these will be held via Zoom. And basically, this Zoom link you have right now is the same Zoom link for everything except for discussion and TA office hours. So all the exams, my office hours, and all lectures will be held at the same Zoom link here. The reason the times are later in the day is to try to, again, help accommodate students who can't make this time because they're doing internships. Yeah. If you have conflicts or anything, please let me know, and we'll try to accommodate. But it may be difficult with the large nature of the class. I guess any questions so far on this stuff? Talk a little bit more about the rest of the syllabus. Just check the chat. All right, excellent. So yeah, as far as grading, so the breakdown be 20% homework, 35% midterm, 45% final. There will be about four to five homework assignments. The first one will be given out shortly and will be due around the end of week two. And how the homework assignments work is that there's going to be a number of problems, and three of the problems will be graded based on correctness. So we will check that your answer is correct and the rest of the problems will be graded based on completeness. So as long as you you know have an attempt to solve the problem then you'll receive full credit on those ones. Now please keep in mind that you know just because some problems are graded by completeness versus correctness doesn't mean the ones on correctness are necessarily more important than the ones on completeness. So when you're studying for exams it's good to look at all the problems. It's just to reduce the grading load and also to reduce kind of stress on you guys. as well. As for the midterm and the final, so these will be held on Zoom at those times, we're going to ask that you keep your camera on. You will be allowed to bring in a, well, bring to your exam a cheat sheet. So this is for the midterm, you're allowed one regular sized paper, double sided, can be typed, handwritten, whatever you want. And for the final, you're allowed to bring two. So you could bring the midterm one plus one more, for example, or any two pieces of paper. Other than that, you're not allowed to use any outside resources, including obviously the computer and internet. So we will be proctoring and kind of monitoring cameras during that time as well. Okay. And yeah, so the class will likely be curved. But the curve will only help you. So if you score at least this percent, then this is the minimum grade you will get, it will likely be higher due to the curve, but yeah, if you get a 90%, you know that you'll get at least an A-, potentially much higher. Now, I don't have like a hard limit on how many A's, B's, and C's there will be. Probably it'll be a third-ish A's, a third-ish B's, third-ish C's or below, but that can change. You know, if everyone does well, then I'm happy to give everyone else higher grades. And that's happened in the past. So yeah, basically, there's no hard cap. Those are my rough estimates. But again, if everyone does really well, happy to give out more A's and B's. There's, yeah, it's not a strict one. Okay, so that's grading. As far as collaboration, so for homework, you are encouraged even to collaborate with other students, talk to other students about your homework, work on the problems, You are not, however, allowed to directly copy from other people. So you can discuss the problem, but we would like you to write your solutions on your own separately. Additionally, you may use the resources in this class, but you're not allowed to, you know, Google the answers or, you know, ask Tab-CVT for the answers. That's also considered academic dishonesty. Now we don't want you to, like, not use the internet ever, right? you're saying, "Hey, I want to learn about more about greedy algorithms," of course, we encourage you to use the internet to look up how greedy algorithms work. What you're not allowed to do is Google your specific problem and then look up a solution for that. So these restrictions are for seeking help on a specific problem, but if you're interested in learning more about these topics, of course, you should and are encouraged to use the internet to find more resources to help you. So hopefully that's clear. And for the homework, again, if you do collaborate with other students, which I very much encourage you to do, you can try to find groups on Piazza, but you should write down the names of the other students on your homework. So just say who you collaborated with and then write down their names somewhere on the homework before you submit it to Gradescope. And then, as I mentioned for the exams, you're allowed to bring in the cheat sheets mentioned, But otherwise, you're not allowed to use any other materials, including course materials, such as a textbook or other notes. And obviously, you're not allowed to use electronic devices, such as the internet, apart from what you need to set up a Zoom camera. Okay. Any questions about the policy here? Let me check the chat really quickly. Okay, excellent. Okay, so some more course policies. So, if you have a conflict with an exam, please send me an email. If you miss an exam and you don't have an excuse absence or anything like that, then that will result in a zero on the exam. If you have an, obviously if you have like an emergency or, you know, something big comes up, you can let us know and we can work something out. But apart from, you know, some sort of emergency or other circumstances, then you'll get a score of zero if you missed the exam. As far as regrade requests, so we will have regrade requests for homeworks and exams, and those must be submitted within one week of receiving your score on the exam or homework. With the exception, the final will be a more accelerated timeline for regrade requests, just because of basically the deadline to submit grades. Regrade requests submitted after one week will not be accepted. We will let you know when the grades are released for certain assignments, and also when the regrade request period will close. So as far as the late policy, so homework assignments will be due at right before midnight on the date that will be indicated. I believe the first homework assignment, which is not yet released, will be released shortly. Well, I'm planning to have due Saturday, week two. The reason it's not Friday is because Friday is July 4th, so I don't want it to be due on a holiday. I recommend you finish it earlier than that, but I decided to give you the full time for that. If you submit it by the deadline, then you get full credit. If you're within three hours late, so between midnight and 3 a.m., 90% credit. If it's within one day late, then you get half credit. And if it's more than 24 hours late, then you're not going to get any credit. And the reason why we're not allowing more credit is because after one day, we will be releasing the homework solutions. And so at that point, you could just look at the solutions there. So we don't accept homework after 24 hours. Now, you should make sure that their homework is submitted correctly. So when you submit it, just double check, make sure that you submitted the right file, that it's in the thing that you intended to submit. So we're not accepting, you know, excuses except for, you know, emergencies. So yeah, if you submit the wrong file or if you get to submit it or you woke up too late, those do not qualify for, you know, exceptions to this policy. If you do submit a little bit late, Again, if it's relatively recent, it's 90%. But I would highly recommend that you double check when you submit that you intended to submit that file. OK. And you can resubmit something, and what will be graded will be the most recent one. So make sure that if you submit the wrong thing and then resubmit it, then all that's before the deadline. And we'll basically do this policy and do the most recent submission. Okay, yeah, so as far as PTEs, so currently there are, the class holds 160 people and there are I think 25 people or so on the wait list. There are some restrictions on course size, not due to, you know, classroom size since we're on Zoom, but just due to the capacity of the TAs and the readers. So how it's currently working right now is that we are only admitting students with PTEs if they must take the class in order to graduate on time. So if you send me a PTE request email then I will forward this to the basically enrollment office and then they're going to examine each of your cases on a case-by-case basis and determine whether or not you absolutely must take this class in order to graduate on time, and if that's so, then they'll enroll you themselves, otherwise your PTE request will be denied. Now it's possible some people will drop off the waitlist, but I'm not sure how many will, and so if you're on the waitlist, I can't really say whether or not you'll get in or not at this point. Probably some students will drop, but also since this is a high demand class, I don't really know exactly how many will drop. So again, if you feel that you know you absolutely do need class in order to graduate, then I will send it to the appropriate resources who will you know check that for you and ensure that you can graduate on time, but that's not the case and you're very far down the wait list then you might not be able to get into this class. If you are not currently on this Bruin Learn page, then if you're able to make it to the Piazza, maybe getting a link from a friend or something, then I will add you at least to the And then, as I mentioned with the email policy, please, if you're talking about technical content in the course, things about algorithms, please post that on Piazza, and email should be only for, you know, personal issues or scheduling issues, that kind of stuff. Okay. One last note here. So, yeah, here are some resources the university has. So again, I spoke a little bit about academic integrity, but if you have any other needs, please contact CAE if you have a disability. Here's some other resources you can use, and of course if you need to talk to us, you can do so as well. And just a couple last notes, so as far as office hours go, the TAs will be having office hours as well, but my office hours will normally be directly after class, so just the hour after class ends. For this week only, I will be holding my office hours instead from 8 to 9 p.m., and I may also add an extra office hours at this time as a regular thing, just because a lot of students cannot make this time here. Okay, so that was a lot of material here. Are there any questions about the course syllabus or any of the class policies? Okay. Yeah, so someone asked about CAE accommodations for exam structure. So generally CAE exams will be proctored by CAE and they will also proctor via Zoom, I imagine. But if there's any difficulties with that, then let me know. But usually, that's how things happen. Any other questions? OK, so someone asked if I will increase class size to enroll people off the wait list. So I am, generally speaking, deferring the enrollment to the enrollment office and their resources. I have someone I know there that I've been messaging about this class. So I did not really expect the class size to increase much. So again, if you're very far down the wait list, it's probably not too likely you'll get in the class and you may have to take in a different quarter. As far as someone asked about how important reading is for understanding the material. So I do intend my lectures to be fairly self-contained, but the reading is very helpful. So I highly recommend the reading. The course material does follow along with the reading fairly closely. And the reading will also give you other algorithms to look at and more examples. There's also a ton of practice problems in the textbook. So if you're wondering, how do I study for the exams? a really good way. It's just to look at the every chapter. There's a ton of practice problems. You can try those out. You can also search for problems online like the code, that kind of stuff. But I think the reading is very important for this class. But I do try to make my lectures also. And again, I don't really care how you get access to the textbook. I just want you to read it. So any other questions about course policies? So in that case, I'll start the lecture portion. Let me stop screen sharing. We'll switch over. Again, feel free to unmute and ask questions if you don't want to use the chat function. Okay, oh yeah, someone else asked, "What habits have I seen from students that contribute to their success?" So, generally speaking, it's good to, you know, make sure you're keeping up with the course content. So, when you, you know, go see, read the lectures, if you're, like, unclear how an algorithm works, you know, going home and thinking about it, starting the homeworks early, and basically not just cramming everything at the last minute. So as long as you're keeping on top of the material and whenever you have questions you're asking them, you're seeking help at office hours, those kind of things is very helpful for students. You know, if again, if you have any questions like we are here to help you, we want you to understand this material, there do exist a lot of resources for you. It's just good to make sure you take advantage of those resources. For those of you who aren't here because you know you have a conflict with time, please make sure you actually watch these recordings afterwards and try to attend the office hours and other things you can that are during times that you can't. So I think I will probably add an office hours at a later time as well just for those students. Okay, so yeah, so let me just spread this is. Yes, 180. Lecture one. 623. Alright, so the first thing we should ask for this class is, you know, what, what is algorithms, since that's what this class is about. And so algorithm design is about problem solving. So this is a class about problem solving. You have a problem. Someone says, hey, we want you to do this thing for us. And you want to figure out a system, a step-by-step procedure for solving that problem. So the definition of an algorithm. This is a step-by-step procedure. Oh yeah, at any point my handwriting is a little hard to read, it does get slightly messier on an iPad. Please ask me to clarify what letter I wrote or what sentence I wrote. So yeah, this is a step-by-step procedure for solving a problem or accomplishing something. So these notes will be posted as well afterwards. All right, so you've already been doing algorithms a ton in this class. So for example, in previous classes, like CS31, 32, you learned how to sort numbers. So bubble sort, insertion sort, selection sort, those are all examples of algorithms that you've done before. And all of those were for the purpose of sorting a list of numbers. So algorithm shows up all the time. So for example, let's say you're UCLA, and a bunch of students want to have housing, and they have constraints. They have lists of roommates. You could have an algorithm to assign students to housing. Or say Amazon is shipping a lot of items out to students, to warehouses, and they need to figure out-- they need to schedule transport. How many things should go to these warehouses? How should we arrange the delivery devices and stuff? So basically, anything where there is a problem and you don't want to solve it using brute force, you don't want to just do something very efficient, inefficient, then we can use an algorithm for to make it more efficient. And then we can implement the algorithm using a computer. So this class is going to be a very mathematical one and not a lot of coding, but I'll talk about that in a bit. OK, so yeah, so in this class, there are tons and tons of different problems, or just in general, in the world. So how are we in this class going to teach you how to solve every problem that exists? And the answer is we're not. We are obviously not going to have time to teach you how to solve every problem you will possibly encounter. Now, what we're going to try to do in this class to teach you methods for solving problems, and also some of the most common kind of types of problems. And what this will allow you to do is that when you see a brand new problem, you can first say, is this similar to a problem I've already solved? And if so, you can use the techniques from that problem. Or if not, you have now a list of like a tools that you can use to help solve the problem. So what we are trying to do is give you a toolbox for tools, so that when you encounter a new problem, you can go look through your toolbox and find a bunch of different tools so that you can use those tools to try to solve the problem. So that's how this class is going to work. Again, we cannot teach you how to solve every single problem you will possibly encounter. Instead, we will teach you the general ways that people have been able to solve these problems along with specific examples. And then the hope is that down the line, when you need these, you will be able to use those tools to give you approaches, ways to start off of figuring out how to solve the problem. OK. So yeah. Now, this class here, I know it's a summer session. And so maybe some of you are thinking this class is less important. You'll spend less time on it. This class is actually very important. In fact, I would say this class is maybe one of the most important classes you'll take if you're a CS major. And the reason so is because this is one of the classes that almost every CS major, regardless of where you end up, will end up using to some extent. So again, algorithms are just problem solving. So again, all the time, you'll be asked at work, if you get a coding job, how do I solve this problem? And then you'll make use of your algorithmic tools. So that's reason number one, is that you're going to use this in your jobs. But reason number two is that oftentimes interviews will ask you algorithms types questions. So this class will also help you prepare for those types of interviews. Someone had a question about a review of CS32 data instructions and algorithms. So for this class, what do you need to remember from CS32? So you should know the basic data structures in the sense of you should know about queues and stacks and arrays and priority queues. You don't have to remember how to implement these or anything. You just need to know roughly what they are and the time complexity. We'll talk about that later on how to access that. So an array can be accessed in a single unit of time. Whereas a linked list, if you're trying to find an element, you might have to go through the linked list. So the level you'll need to know there, again, You don't have to know actually how to implement these. You just need to know that certain data structures exist. And later down the line, you also need to know the time complexity for accessing elements, adding elements, that kind of stuff. And we'll talk about that a little bit later when we get to it. But yeah, good question. All right. And also, if you're reading chapter one of the textbook-- sorry, one of the chapters later talks about priority queues. You won't need to know anything about priority queues apart from what they are and again the time complexity later on of how to access elements. Okay, so question, so yeah, so two main focuses of the class, two main focuses. So one is algorithm design. So again, this is what we just talked about, how to design algorithms, and also learning what are called paradigms, which are just methodologies for solving algorithms. So learning algorithmic paradigms and general methods for solving problems. Again, these are some specific algorithms, as well as giving you the tools to solve problems in the future. The second focus of the class, which I haven't talked about as much yet, is complexity analysis, which is that once you have an algorithm, how do you determine how good is it? How fast is the algorithm? Do we expect an algorithm to be better or worse than another? And so the complexity analysis we'll focus on in this class will be the time complexity or how fast, how many units it takes to run, but in general there might be other types of efficiency you care about such as power. But yeah, so this will be a method for basically taking the algorithm and saying actually how efficient is algorithm? Is it a good algorithm? Do we expect it, this other algorithm to be better or why or why not? Okay. Yeah. Okay, so yeah, a couple more things then about this class. Again, this is what we're trying to do. Like I said, this class is very important in terms of you will need this probably for your jobs, and you will also need this for your coding interviews. This class is also a very difficult class. So this class needs to do a lot. So first of all, this class is trying to teach you proofwriting. So this is probably one of the first classes that's really gotten into proofwriting. It won't be enough just to write down an algorithm that works. We want you to also show and analyze why it works. And so I understand this will be fairly new to a lot of students. You might have seen some of this in math 61. But it's a very proof-focused class. And in fact, there will not be any coding involved in the class. So there's not going to be coding projects, but we will want to write the algorithms at a level that you could implement it if you want to. So yeah, so the second thing we want you to do is be able to write down the algorithm sufficiently enough that if you needed to code it, then you could. And that's actually a good exercise to do if you're trying to make sure you understand how it works is to try coding it and see what happens. And then obviously, the last thing we're trying to algorithms. So there's a lot of content in this class. It is a difficult class, especially if you're not as used to math and proofwriting. We'll try to ease you into that a bit, but there's a high level of rigor required for this class. This will probably require a lot of time to do, even though there aren't actually any coding bugs. So again, I do encourage you when we go through algorithms to try to implement these at home, and I will kind of give also more guidelines for, know what is a sufficient proof, what is considered good enough to get full credit on exams and homeworks and that kind of stuff. Okay. All right. So any other questions on just algorithms in general or about this class as well? Okay. All right. Oh yeah, and one other thing too is we'll have a break at the halfway point as well. So it won't just be two hours straight. We'll talk for a bit and there'll be a break and then we'll go again till 1150. All right, so the first problem we're going to talk about is just kind of to introduce you to an algorithm. It's actually a very cool algorithm and it's used in real life. So I'll kind of explain what this algorithm is used for, but it will be kind of an example of how to approach a new algorithms problem before we go into like specific techniques. So this is what's called the stable matching problem. Stable matching problem. You'll sometimes see it called the stable marriage problem, but I'll just call it the stable matching problem. And the first thing you want to do when you see a brand new problem is you want to make sure that you understand the problem. So this is very important. So always make sure you understand what the question is asking, or what the problem is trying to have you do. Okay, and why is this important? Well, first of all, if you solve the wrong problem, so if you don't understand what the problem is doing, you might solve the wrong problem. If you solve the wrong problem, then your clients will be unhappy because the algorithm is not doing what they want, and your answers will be incorrect in some sense. And then you'll have also wasted a lot of time not solving the problem that you were being asked to solve. So you want to make sure-- yeah, you want to solve the right problem. And the other reason, too, is that you want to make sure you're doing what is being asked. So while it is nice to generalize problems, and there are a lot of cases where you do want to generalize your solutions to fit a lot of cases, there's a lot of times also we're adding all these extra bells and whistles, are not what is asked for. And the algorithms are going to be a lot slower and less efficient because you added all these extra things that weren't wanted. So just as an example, back during COVID, I had a friend who did, worked on a COVID tracking algorithm for tracking who had COVID or not. And they actually went to the clients and said, "What do you want?" And the clients gave them a list. And then they implemented that specific list of things. And they were a lot more successful than some of the other groups because the other groups had like more inefficient things that did a whole bunch more, but that was not what the client wanted. The client said, we just want these things and we want something that does these things quickly. And so it's good to ask what is actually needed? Do I need to generalize? And it can be useful to generalize again, but sometimes it's not like you can get way faster things if you don't generalize, if you just focus on the actual problem at hand. So I will summarize this part as you just want to make sure adding extra features may lead to slower outcomes. Okay, so at any point in this class, if I introduce an algorithm, and before we get around to solving it, if you do not understand any part of the algorithm, you should ask about it. So a good way to approach a problem. So yeah, let me just say the general approach. general approach. When you see a new problem, step one, make sure you understand the problem. So read it carefully, look at the definitions, and then you can like create toy examples for yourself. You can say, okay, let's say we only have three people or something. What happens here? You can say, okay, let's look at the edge cases. So, you know, step one, at the problem, look at the edge cases, play around with a little bit to make sure you actually understand what's happening in the problem. Now I will, for the midterm and final, try to make the problems as unambiguous as possible. The homework assignments are often from the textbook, so some of them may be a little bit more ambiguously worded. I have tried to eliminate some of those ambiguities, but in terms, at least for the exams, I will attempt as best as to have no ambiguity on, you know, what the question is asking. But of course, you're welcome to ask questions during the exam as well. All right, so once you feel like I've understood the problem, I know what I'm trying to do, then what you're going to do is try to figure out how to solve it. So this will be a large focus of the class is how do you come up with, I'm sorry, an idea for solving the problem. So some common ways are, one, you see, is this similar to a problem I've solved before? Problem I've solved before? And if so, that's great, because now you can go look at the problem you solved before and see, hey, what happens if I try to apply this algorithm I solved for a related problem here? What changes do I need to make? It gives you a good starting point. You can say, this looks kind of like that, so maybe something similar will work as a solution. So that's always a good thing to start with, is that if you have seen lots of problems, then you can look for ones that are similar. The second way is you can try-- oops, sorry-- try some of the algorithm Paradigms, you will learn. So again, we're going to teach you a variety of methodologies for solving problems. So you can say, okay, I'm gonna try this type of algorithm. And that gives you a starting point to try to solve it. Okay, so now you've come up with idea, you have a starting place. You say, we're going to try this. Now, when you try something, you then need to figure out, does this actually work? So the third step after this is you say, here's something I think might work. Then you're going to analyze if it does work. So you'll analyze the correctness and efficiency of your algorithm. And change it, modify if necessary. Modify if necessary. And if it just completely is not working at all, you might have to go back to step two. So if it doesn't work, go back to step two. So oftentimes, oops, apologies. Okay. So oftentimes it's a very iterative process. So what you'll do is you'll say, here's my idea. I think it might work. And then when you go to analyze it, that's where you find out, oh, it doesn't work in this case. And then what you can do is you can say, okay, let me make these changes so that now it'll work. And then you can go back and say, oh, now this thing is not working. And then you go back and forth. So this is generally what you're going to do. It's not that often that you'll just immediately come up with the correct solutions right on the spot. You often have to try something, check what happens, and then make modifications until it works. Sometimes you might try a type of algorithm, and that doesn't work entirely. You might have to use a different paradigm. So this is a very back and forth process here. And so this is kind of why in this class. Yeah, so in this class, like I mentioned, you're going to have to also prove that your algorithm works and that might seem a bit overkill to you guys because you're thinking maybe the company only cares if my code actually just works, why do I have to prove that it works? And the reason we're trying to have you prove that it works is because by proving it, we are teaching you kind of how to better understand and analyze these algorithms. So these tools, the proof building is really helping you learn how to kind of really think about and approach these problems, how to really like reason about why this might be correct or not. And that will be useful down the line. Okay, someone asked what's my methodology for thinking about edge cases when understanding a problem. So we'll do some examples of this, But you can imagine that you're some sort of annoying person whose job is to break someone's algorithm. So imagine someone wrote an algorithm and you're trying to be as annoying as possible. So you're looking for vulnerabilities. You're saying, okay, what if I have the number of things equal to zero? What if I have, so like off by one errors kind of things, But yeah, like after writing an algorithm, you can pretend that you're like a hacker or someone and you're trying to break it. So just think, where are their vulnerabilities? Are there like really weird inputs I could do that might make it do weird stuff? So that's how I kind of tend to look for edge cases. But again, we'll show some examples. I haven't even introduced the problem yet, but this is what you'll be doing all the time in this class. You'll see this kind of approach constantly. And right now, what I'm saying is this step here, understand the problem. You can't progress to the other step without doing that first. OK. All right, sorry. So any other questions about this general methodology? OK. So what is the stable matching problem? So let's call this the problem specification. So what you're going to be given is a set of n, where n is some number, hospitals. So we'll call this set H. And H will hold hospitals H1 up through HN. Also, if at any point you're confused by notation, I will be using some sort of mathematical consent notation. I'll try to define ones you might not have seen before. But if you're confused by what that means, please ask about that. OK. And then you also have a set of N students, which we'll call S, capital S, which will be students S1 through SN. And you're also-- so this is the input. You're also going to be given a ranking list. So imagine that students want to be assigned as a residency program to hospitals. Every hospital wants to accept a student. And hospitals have students they like more than others, and students have hospitals they like more than others. So each hospital has a ranking of all the students. Hospital has a ranking or a preference list of every student. And each student has a preference list or ranking of every hospital. OK. So this is what the input is going to look like. And my first question to you guys looking at the input is that is there anything that seems unclear to you about the input? Any ideas? There's going to be like a one-to-one correspondence right? Like each hospital only has one student? Yeah, so good question. So down the line, yeah, right. We haven't talked about what we're trying to do with the input. But down the line, we will be trying to assign students to hospitals. But yeah, so I guess some ambiguities here that is that one, like, can students-- can a hospital rank two students the same? And the answer for this will be no. So for this preference list here, What we'll say is that no two students or hospitals will have the same ranking, will be assigned the same rank on any list, on any single given list. So they can be-- two students can think the same hospital is their favorite hospital. But with it, you can't say, I like this hospital equally this hospital. You have to say if you're a student, you have to say this is my first choice and my second choice and my third choice all the way down. You're not allowed to have ties. And secondly, you must include every hospital or student on the list. So if you're a student, you're not allowed to leave out hospitals. You have to say here's every hospital in order, how much I like them with no ties. Okay, every student hospital on each ranking list. Okay, so again, so far this is the same thing. And imagine again you have a bunch of students who just graduated with you know MCBB or MIMG majors and they want to go to med school and, sorry, they've already graduated from med school, and now they're trying to go to a hospital for a residency program. And in this case, every hospital is going to have a spot for one student, and you want to, down the line, you're going to want to assign students to hospitals such that everyone's as happy as possible by some measure. So that's kind of what we're going to be doing, and in fact a variation of this algorithm is used actually nationally to match students' residence. This is called the National Residency Matching Program, and we'll talk about that later. Okay, so I'm going to be very formal with these definitions, just to kind of get you used to kind of thinking about these things formally. So let me define some more definitions before we get to what the actual problems asking. So a matching, this is a set of ordered pairs, each from H cross S. So basically a matching will be a pairing between students and hospitals where every student is paired to at most one hospital and every hospital is paired to it most once students. Where? Okay, so if you haven't seen this location h cross s here, these are the set of pairs h comma s such that h is a hospital and s is a student. So again, how do you read this? h cross s is the set of pairs where The first element of the pair is a hospital. This means h is an element of capital H, the set of hospitals, and the second element s is a student, because s is an element of the set of students. That's what this means. Okay, so you have a set of hospital-student pairs where each hospital h appears in at most one pair. At most one pair. And same for the students. Each student s appears in at most one pair. So you can imagine, as a picture, suppose you have the hospitals here and you have the students here. Then you want to match them up. So maybe this hospital is matched to this student here. So let's say this is H3 and this is S2. Then the fact that we're matching H3 to S2 indicated by having the pair H3, S2 in the matching. And this means H2 paired with S2. So that's how you can write this out, is that you can create a list of pairs. And again, H3, S2 being in the matching just means that we're going to be pairing them together. So here you can have some more pairs. You can have maybe this guy paired with this guy. And because of matching, not every student-- oh, yeah, so what does that mean that H3 is paired with S2? Is that down the line, I'm going to be trying to assign students to hospitals. So pairing would mean that a student is assigned to the hospital. So I'm going to be trying to match students with hospitals. So a matching will be a set of who's matched with it. So here in this drawing I've drawn, I would be assigning student 2 to go to hospital 3. No, as in the writing. Someone asked-- oh, yes, sorry. I didn't mean age 3 paired with age 2. Yes. Good catch. And since it's, again, it's just a matching, At most one pair means it's OK for students in hospitals not be matched. Now, because we have the same names as students' hospitals, we're actually going to want every student to be matched to every hospital. So let me add a new definition, which is a perfect matching. And this is the same thing, except that instead being at most one pair is going to be exactly one pair. So set of ordered pairs where now is going to be exactly one pair. So a perfect matching is a matching. But now when we have H and S, every student and every hospital has to be matched somehow. So nobody is allowed to be left out, and nobody is allowed to be paired with multiple hospitals or multiple students. Okay. All right. So, with this definition here, I'm going to ask my first question, which is not going to be the real algorithm, so this is more of a toy problem, but here's a problem, is that given a set of students and hospitals, give an algorithm to find a perfect matching if one exists. So let me write this down. Given the preference list of n hospitals and n students, give an algorithm to find a perfect matching perfect matching if one exists. All right. Anyone have any ideas for how to solve this? So I have n students, I have n hospitals. Every hospital student has ranked everything on the other side. And I'm asking, is there a way to find a perfect matching between the hospitals and the students? And here's the definition of a perfect matching. We can try to, like when we make a pairs, they're going to be both hospital and student health is going to have like a ranking. Okay. And we want to minimize those numbers. So like some, come up with some algorithm that like iterates and tries to minimize the sum of the rankings. Okay. So yeah, you're looking at the preference and you're saying we want to try to find something that will minimize, you know, like make everyone happiest, make the preferences the best. But here's some part, again, that we will want to do that down the line. But if you look at the problem, the problem does not care about the preferences. So what do we look? Perfect matching. Does the perfect matching say anything about preferences? It does not. And so this is kind of a part of making sure when you read a problem, you know, you're given this preference list, you're thinking naturally we'll want to use them, which we will down the line, but this specific problem is not actually asking you to maximize preferences. So again, make sure you know, you're actually looking at the problems asking, you're looking ahead and thinking about the problem we do want to solve down the line. So we'll get back to that as well. It's a very good observation, but for this problem at hand, actually someone mentioned the chat. They said the easiest way is just to match, you know, H1, S1, H2, S2, and so on and so forth. So, yes, this is the solution for this problem. Because we only asked for a perfect matching, and a perfect matching just says every hospital has to be matched to exactly one student, and vice versa, well, we can just match student 1, hospital 1, student 2, hospital 2, and so on and so forth. So solution is assign student i or hospital i, i to student i for all i. Yeah, so again, we're asking about preferences in this problem. So you can just solve it by just saying, you can view it kind of as following. You're just matching the first hospital, the first student, the second hospital, second student, third hospital, third student, fourth hospital, the fourth student. Now you know when we're thinking about this is ignoring all their preferences, obviously. So this is not going to be what we want in the future. this is enough for this toy problem. All right, any questions about the toy problem? And so a follow-up question is, does a perfect matching always exist? Any ideas on this? Okay, so someone said yes, and the answer is yes. And how do we know the answer is yes? Well, the answer is yes in this case. In this case, because number of hospitals equals number of students. And the reason we know it's yes is because we literally just said, "Here's a solution," and the solution did not have caveats under which it looks. So yeah. Yeah, so for those who know what bijections are, yeah, this is a bijection. So there's a perfect match. Okay. So I'm just going to finish up, then. The extra definitions we'll need to define the problem, and then we'll take a short break and then talk about how we might try to solve the problem. OK. So again, we're trying to match hospital students. And so far, we haven't said anything at all about the preference list. And that's bad. We actually want to care about the preference list. So rather than saying, here's what we want, we're going to say, here's what we don't want. And the thing we're not going to want is that after we've done the matching, we don't want pairs to want to switch. So this is what we're going to call instability. Instability. OK, so we'll say that a perfect matching M has an instability if there exists two pairs. there's hs and h prime s prime in m such that h prefers s prime to s, and s prime prefers h to h prime. OK. So let me kind of draw this out pictorially. So we have H and we have H prime, oops, I'm pressing the wrong button, and we have S and we have S prime, and currently the blue is in matching. This is the matching. So H has been paired with S and H prime has been paired with S prime but unfortunately H actually prefers S prime to S. They say I like S prime better than my current pair and S prime says actually I also like H better than my current pair. So this is basically we have Alright, so red, H and S prime prefer each other over their current match. Okay, and this is called an instability because maybe H and S prime will say forget who we got matched to, I'm gonna say forget that and we're gonna go sneakily match each other and you know revoke our offers. So imagine you know You have this algorithm, you tell the hospital, here's who your student is, and you tell the students who's where your hospital is, and the hospital looks at this list and says, "Hey, I really wanted that student," and the student said, "I really wanted that hospital," and the hospital says, "You know what? Forget the algorithm. Hey, current student, we're not giving you an offer. Other student, you want to come to us?" And then their student says, "Sure, I'd rather go to you than my current hospital," and then they just, you know, you know, renege on their deal. get paired up together and then H prime and S are kind of doomed. So this is why it's called an instability. If you look at it, there are some people who, namely H and S, who have an incentive to not actually go with the matching and go off their own and pair together instead of doing what they're supposed to. So that's what we're trying to prevent. In the version of this called a stable marriage problem, where they're marrying men and women, you know, there's like two people might want to elope with each other because they like the other partner better than their current partner. Okay. All right. Any questions on what an instability is? I want to know if there's only one solution for each set of H and S that comes into a stable solution. That's a good question. We'll talk about this a little bit later. Let me actually just write down what the problem is asking. One last definition. I know there's a lot of definitions. A stable matching is a perfect matching with no instabilities. No instabilities. And the goal, as you might have deduced, is to given the preference list of n hospitals and n students. Find a stable matching. So now you have to care about the preferences, because they can cause instabilities if one exists. So some related questions is, one, is there always a stable matching? That's a very good question. And secondly, if there is a stable matching, is it unique? So we will talk about that a little bit later. When you're given this problem, these are good things to ask. Just explore the problem. See what do you think? Is there always a stable matching? Should it be unique? Great questions to ask. So with this, we're going to take a quick break until, let's say, 11.15. And then we'll start talking about how to solve the problem. But yeah, so again, let me know if you have any questions about the problem itself. And you can start thinking about how you might try to solve this. And then we'll take a break right now. I will actually pause the recording during the break. All right. So again, what are we trying to do? have hospitals and students. Hospitals say they like certain students better. Students say they like certain hospitals better. And we want to find a way to pair every hospital with exactly one student and vice versa, such that there's no hospital student who would rather pair with each other than their current match. OK, so let's do a very explicit example. So I'll call it section 2. It's an example. So let's say S was Alice, Bob, and Charlie. You have three students, ABC. And the set of hospitals was, say, UCLA Health, and then Cedars-Sinai, Cedars-- I forgot to spell it-- Cedars-Sinai, and then Kaiser. And the preference lists are as follows. So Cedar Sinai says that it likes Alice, then Bob, then Charlie. So this will be ABC. And then UCLA says that they like Bob first, and then Charlie, and then Alice. Kaiser says that they like Alice, then Charlie, then Bob. And on the student side, Alice wants to go to UCLA, and then Kaiser, and then Cedars-Sinai. And then Bob also wants to go to UCLA first, and then Cedars-Sinai, and then Kaiser. And then Charlie wants to go to Kaiser first. And then Cedars-Sinai. Okay. So again, three students, three hospitals. And each hospital has told us which students they want in order. And every student has told us which hospitals they want in order. So this is generally how the problem will look like, except you can imagine that the number of students in hospitals gets very, very large when you actually put this on a national scale. Okay. So the first question is, "Find a stable matching." I guess not a question, but the problem. So, here again, there should be three pairs. Each one should have a student in a hospital, and we want them such that, Again, no hospital and student likes each other better than their current match. So any ideas on A-stable matching here? We can try to just match first to first, second to second, third to third, and then some kind of sorted-- - You wanna do, how do you wanna do it? - Yeah, the first to first, second to second, third to third. - And then? - And then try to like see if there's any matches that want to flip, and then start to like flip them and keep it as long as-- - Okay, so you're trying to give me an algorithm for solving this? Or, okay, I think you were trying to say, start doing this match and then see if we should swap any of them. - Yes, yes, that's what I was gonna say. - Okay, yeah, so let's say we do this match. Is this good or do we think anyone's gonna wanna swap? What do people think? Okay, so someone's saying Alice could go to Kaiser. And so, this matching here. So let me let me write this below. This was my event question 2, which is find a perfect matching with instability. And this would be Cedar Sinai, UCLA, Kaiser, matched with Alice, Bob, and Charlie. so the one we just drew and this is an instability. Why? Because as someone just said Alice prefers Kaiser to Cedar Cyanide and Kaiser prefers Alice to Charlie. So Alice prefers Kaiser to cedar cyanide and kaiser prefers alice to charlie so it's totally possible that alice and kaiser might say i forget charlie and cedar cyanide we're going to go match with each other okay so this will not work all right but we could try swapping stuff right so I'm going to have an idea of a matching that would be stable. I didn't get the name of the previous speaker, but I think if you just make that swap, so Alice goes to Kaiser and then you match the remaining two, CS to C, I think that's a stable matching. Okay, yeah. So UCLA is matched with Bob. We'll do this in red, I guess. Alice is matched to Kaiser. and cedar sinai is taxed to Turk. Okay, so yeah, turns out that this will work here. So basically Bob, the way you kind of reason about this informally is that Bob and UCLA are both at their first choice. So they're never gonna swap, right? They already got their favorite choice. And then of the other two pairs, right? We could either match CS to Alice and Kaiser to Charlie, which results in instability. Or if we swap them in this way, Well, Alice and Kaiser both like each other better than the options, so they're not gonna wanna swap to this case here. And then Cedar and Cy and I got their last choice, unfortunately, but that's because their first two choices had other places they'd rather go that were options. So this is indeed a stable matching. The way you could write this, if you wanted to be formal, you would say M is the set of pairs, CS, C, UCLA, B and Kaiser, A. So that's how you can formally mathematically write the matching, which is pictorially represented. Okay. So yeah, so those are just a concrete example of what it actually looks like to find a matching with the prefaces. Okay. - I have a question. - Yeah. Alice ranks UCLA higher than Kaiser. So why wouldn't Alice want to switch to UCLA? - Ah, yeah. So good question. So we see here that Alice actually likes UCLA more than Kaiser. So Alice could go to UCLA and say, "Hey, UCLA, I don't want to go to Kaiser. Will you take me?" And here is where it's not an instability because UCLA says, "Well, actually no, because I like Bob more than you." So while Alice has to go to San Francisco, UCLA doesn't because UCLA said, "Alice, I like you the least, and I like Bob the best, and I got Bob already." So UCLA will decline Alice's offer to swap. So instability only occurs if both parties want to swap. And it's okay if everyone wants to go to UCLA, for example, but UCLA said, "I already picked my favorite students. No one else can go there." But yeah, good question. OK, another question you might ask is, can there be multiple different stable matches? What do people think? And maybe not with this example, but another question. Can there be multiple different stable matches? Someone asked if I can explain CS, Kaiser, and Alex Charlie again. Okay, so here we've, again, I haven't explained how we could come up with this. This is a small enough case you could brute force all the possibilities. but let's imagine we paired UCLA to Bob because UCLA likes Bob and Bob likes UCLA. Then between the other four remaining guys, we can either do Cedars-Sinai with Alice and Kaiser with Charlie, which is down here, or we can do this case where we swap them. So in the case where we have Cedars-Sinai pair of Alice and Kaiser paired with Charlie, then we look and we see Alice actually likes Kaiser more than their current match. And Kaiser also likes Alice more than their current match down here. So Alice could send a message to Kaiser to say, "Hey, will you take me?" And Kaiser says, "Yeah, I like you better than my current match." And that's an instability. In the opposite case here, where Cedar Sinai is paired with Charlie and Kaiser is paired with Alice, Alice is never going to want to go to Cedar Sinai because they're already at least with Kaiser which they like better than Cedars-Sinai. So even though Cedars-Sinai might approach Alice and say, "Hey, you want to come to us?" Alice says, "No, Kaiser's better than you." So in my, in Alice's opinion, so Alice's declines Cedars-Sinai's offer. Now Alice might say, "I only got my second choice. I wonder if UCLA would take me." So Alice could send an email to UCLA saying, "Hey, UCLA, you want to take me?" And UCLA would say, "No, I don't want to take you because I already got my first choice, Bob and you're not my first choice. So here we're not having instability because we're not having a pair that is willing to switch. So while individuals might want to switch, right, Alice wants to go to UCLA, Cedar-Sinai wants Alice, if the opposite party is not willing to switch from what they currently have, then the matching is called stable. So that's what's happening here. Um, yeah, so someone asked about option UCLA got excluded because UCLA and B matched. In both these examples, we matched UCLA with Bob, and, yeah, A was not allowed to match with UCLA because UCLA would rather be with Bob. And in fact, any pairing where UCLA and Bob are not matched is going to cause a problem because UCLA and Bob both have each other as their first choices, so they're always incentivized to split off from whoever they were actually paired with. So, you know, this isn't a proof right now, this is just kind of some informal reasoning. Okay. So, as far as multiple different stable matchings, in this particular case, someone answered no. So, in fact, this particular example does have a unique stable matching. I won't explain. I will prove that right now. But in general, the answer is yes. So just as an example of this, let's say the set of students was just Alice and Bob, and the set of hospitals was just UCLA and Cedars-Sinai. let's say the list was that UCLA likes Alice then Bob and Cedar Sinai agrees and says we like Alice and then Bob. And then Alice says I like UCLA then Cedar Sinai. I'm sorry, Alice says that she's like UCLA and Cedars-Sinai, and Bob says that he also liked UCLA and Cedars-Sinai, so the hospital students both agree on who their favorites are. Then there are two stable matchings, and one of them is that every hospital, so UCLA goes with Alice, And Cedars-Sinai goes with Bob. Or UCLA goes with Bob. And Cedars-Sinai goes with us. And the reason this is stable is in the first case, UCLA got their first choice. Okay, so basically Bob can ask UCLA, all he wants to switch, but UCLA got their first choice, so they're not gonna swap. And Alice does not, Alice also, like UCLA and Alice are both happy, they got their first choice, so they're not gonna swap. And the second case, we have that, did I do this right? Okay. Bob's with UCLA, which is his first choice. So Bob's not going to want to swap. Wait, sorry, I might have done this. I see it should be in-- let's see. Let me double check this. This one's not-- OK, I think I'm at-- to do it the opposite here. I think it should be like this. OK, so-- no, no, it's the same. OK, yeah, so-- Yeah, so okay, let's say, so here Bob is paired with UCLA, and then UCLA can ask Alice. Oh wait, maybe this one is. I will double check this one. Okay, yeah, so in the latter one we have this matching here. And then we see that Allison and Bob are, sorry, this one's not saved. Allison and UCLA are incentivized to swap. Okay, I think I miswrote this example down, but in general the answer is yes, I will fix this example later. My apologies. We'll fix later. So yeah, so ignore this for now, I will fix this later. Alice should be Cedars-Sinai UCLA. Okay, I think that is. Yeah, I think that's probably worse. Yeah, okay. So in the first case here, If Bob wants to go to UCLA, then UCLA will say, "No, I already got Alice." And if, no, then Alice and Cedar Sinai will swap. If we swap for Cedar Sinai, B and then A, I think it will work. Like this? Okay. Yeah, this should, I think this is right. So in the first case, basically, the hospitals get their first choice. So they're happy and won't want to swap. And in the second case, the students get their first choice, so they don't want to swap. Apologies for that. Yes, this is the fix. So why is the first case stable? Is the hospitals get first choice. And in the second case, the students get first choice. And that's why they won't swap. So in the first case, they won't swap because all the hospitals are not going to swap. And the second case, they won't swap because all the students won't swap. Okay, yeah, apologies for that. I copied that wrong. It's my notes. But yeah, in general, there are ways to get multiple different stable matchings. And we can already see that, right, this one's better for the hospitals because they're happy, they got their first choice. And this one's better for the students because they got their first choice. And so not all stable matchings are equal from the perspective of our students or hospitals' favorites. And we'll talk about that a little bit more. Okay, yeah, apologies for that. Any questions about this? So as long as like one person or one hospital gets top preference, it will be considered stable matching? Yeah, so that's a good question. So the question was like, if one student or hospital gets their top choice, does that mean the resulting assignment is stable? In these examples, it was small enough that there weren't a lot of cases, but in general, no, like, okay, so if all the hospitals get their top choice, then yes, it will be stable. And if all the students get their top choice, then also yes, it will be stable, but it's not always possible for that to happen. So just having a single hospital student get their top choice, you know, there could be instabilities with everyone else. But if a hospital student get their top choice, then they're not going to be involved in instability, because they're not going to have any incentive to switch. OK. Any other questions on this? Is it possible that there doesn't exist any stable matchings? So every time I swap, we end up in the loop of swapping? Yeah, good question. So the question was, is it possible for there to not be any stable matchings? And the answer will surprisingly be no. But the proof of the answer will be that we're going to create an algorithm that always outputs a stable matching. And it's a little surprising 'cause you're looking at this and you're like, it doesn't necessarily seem like it should be true that there's always a stability. And again, the proof of this down the line will be we are writing an algorithm that always outputs an answer. So therefore such an answer must exist, but it should not be obvious at all at this point be true. But that's an excellent question and again these types of questions are good things to ask when you're first approaching a problem. You know, asking is a solution possible? Are multiple solutions possible? Is the solution unique? These are great things to think about. So depending on our initial list we will end up in a different stable matching if there exists different ones. Sorry can you say that again? So depending on our initial list that we choose and we start to keep swapping, we will end up in a different stable matchings. Yeah, so I guess depending on the initial preference list might change how it differs, and also depending on what algorithm you do might also change what the stable matching is. In fact, the algorithm we will use will always output the same stable matching, but in general there are multiple ones and you could try different things. Okay, so for this one again, this is a down the line will kind of have you more solve the problems, but I'm just going to give you the solution for this one. And then we'll talk about kind of why does it work and the solution is going to be a very simple procedure. But if you're just asked, solve this problem however you want, we don't care about efficiency, then there's a brute force solution. So if you look at students in hospitals, there's only a finite number of student and hospital possible matchings. And so theoretically, you could try out every single one and just check each one by looking at every pair of pairs and saying, is there an instability? Now this is extremely inefficient, but this is actually correct. So the brute force solution of try every possible perfect matching and see if it's stable does indeed work. But in this class, we don't want those types of solutions because that would take way, way too much time and it's inefficient and I want stuff that's better. But I just wanted to point out that often there are brute force solutions, but we want to do better than brute force. Okay, so what is the Gale-Shapley algorithm? This is named after Gale, two people called Gale and Shapley. So algorithm, okay, so this is the high level one, and by high level, I mean that I'm not gonna be talking about data structures yet, we'll come back to that. Okay, so Gale-Shapley, and it takes its inputs. So I'm writing this kind of a pseudocode, preference list for 10 hospitals and students. All right. So it's going to start with-- this is the empty set. So it's set of matchings of empty. And then what it's going to do is it's just going to go to the hospital. And the hospital is going to ask their student who they want to match with. they're going to pick their first choice. And the student will either say yes if they're unmatched, or they'll say yes if they like them better than their temporary match. So let me just write this down. So while some hospital H is unmatched and hasn't made an offer to every student. Then what we'll do is we'll let S be the highest. So OK, so you don't look at hospitals, and there's a hospital, and they don't have a current match, and they haven't asked every student to be their match, then they're going to basically make an offer to the highest student on their list who they have not yet asked to be matched with them. So let S be the first student on H's list to whom H has not yet made an offer. offer. Okay, now basically H will say, "Hey, I haven't made an offer to you yet and you're my next highest student." And if the student does not have a current match, they'll say, "Sure, I'll be your student for now." So if S is unmatched, we are going to add the pair h comma s to m. So what does it mean to add the pair to m? We're just going to say we're going to match for now hospital h with student s. So the first hospital asks the first student, the first student is unmatched, and they say sure I'll pair with you for now until I get something better. And then however if s is already matched, then s is going to say who am I currently matched with and who are you? And if they like their current match better, they're going to say, no, I don't want to be with you. And the hospital doesn't, you know, they have to go ask their people. And if they like the hospital better than their current match, they're going to reject their current match and go with the new hospital. So we'll let H prime be current partner of S. So if S is currently matched, then they have some current partner we'll call H prime. And if S prefers the new partner to their old partner, then we'll remove the old pair from S. So we no longer match S with H prime. And I'm going to match s to their new partner h. And otherwise, if s says, no, I actually like my old partner better, s will just reject h's offer. Leave offer h. This leaves h unmatched. Okay, and then finally, we'll return matching. So again, here's the algorithm, how does it work? So every hospital who does not currently have a match, one by one, will go down the list. They'll ask their favorite student, who they haven't asked yet. And if the student does not currently have a match, they'll say, "I guess yes for now." And if the student currently has a match, if they like their new match, then the guy who gave them the offer better, then they'll break up with their old match and go with the new match. And if they like their current partner better, they'll say, "No, don't want to be with you." And the hospital will have to move on to someone else. And that's the entire outcome. Does B say if S is unmatched? Yes, this says B, sorry my handwriting, if S is currently unmatched. Sorry, I had a quick question. Yeah. So the hospital is a start from the, their first choice right? Yeah. Yeah, the hospital will start from their first choice. So let's do an example of this with our example from before. M is the set of matchings, so when we add hs to m, that means we're matching hs, and when we remove sh prime from m, that means we're removing the matching. So yeah, so let's do it with this example here. make it more concrete. All right, so here's an example. So how would the algorithm work? So we'll just go through the hospitals in order. In fact, it doesn't matter which order you go through them. So step one, A will ask cedarsinide to be with them. Cedarsinide is currently unmatched, So they say, OK-- sorry, that's wrong. Sorry, Cedars-Sinai has A, because A is their favorite. A currently doesn't have a match. So A will say, fine, I guess so for now. I'll be a batch with you. So this is the current matching so far in the first step. All right, the second step, we go find a hospital that's not a match. Let's say it's UCLA. UCLA makes an offer to B. B says, yeah, I don't have a match. Why not? And so they get paired together. So we have CS and A. And then we add the new pair, UCLA and B. And the third step, I'll do it in a different color. Cedar-Sinai is going to ask their first choice. And their first choice is Alice. And Alice says, hmm, let me see. Kaiser or cedar cyanide. You know what, I don't actually like cedar cyanide that much. I'm going to break up with cedar cyanide and I'm going to be with Kaiser instead. So that's what happens. So we get rid of the pairing between cedar cyanide and Alice. We keep the pairing between UCLA and Bob and we add the new pairing where Alice broke up with cedar cyanide is now with Kaiser. like so. Now step four, cedar cyanide is you know they don't have a match anymore so they have to make a new offer. Well they already made an offer to Alice so they go down their list and say who's the next person I care about? Oh Bob. Let me make an offer to Bob and Bob says okay let me see UCLA who I'm currently matched with or cedar cyanide. I don't actually like cedar cyanide that much and And so they say no. So in step four, the matching remains the same because Cedars-Sinai made an offer to Bob, but Bob didn't actually care for Cedars-Sinai, so we get to them. Now Cedars-Sinai said, they make one more offer this time to Cee. And Cee, no one's asked Cee to be on their team yet. So Cee says, "Okay, sure, I'll be your match for now." So then they get matched. UCLA Bob, Kaiser A, and then Cedars-Sinai C. And now we look and we say every hospital's matched and we're done. So now we're done. So that's kind of how the algorithm works. So I mean, I should have done this slightly different colors. me clean this up a little bit. So yeah, so step one, Cedar Sinai asks Alice, Alice says yes. Step two, I'll do pink maybe. UCLA asks Bob, Bob says yes. Step three, Kaiser asks Alice, Alice says yes and breaks up with Cedar Sinai. Step four, Cedar Sinai, now that they have no partner? Ask Bob. Bob says no. And then step five, Cedars-Sinai asks C. C has no partner. They say yes. And then we can click. Oh yeah, so good question. Someone said, if we start with UCLA, will it make any difference? Right? So here, when we first started, we had a choice to start with Cedars-Sinai. I It turns out that it doesn't really matter. Well, let's see. So for this case, there's a unique matching, like a unique stable matching. So it won't matter who ends up, like which order it is because there's only one stable matching. And it turns out this algorithm will always give you a stable match. In general, it will also turn out that the hospital ordering ordering doesn't matter either, which is very surprising. But we might not have time in this class to prove that. So yeah, I guess the general answer is it won't matter whether or not you start with UCLA, even if there's multiple stable matchings. But we may not have time to prove that in this class. OK. Any questions about the algorithm and how it works? In this algorithm, do the hospitals overall get the higher preferences as opposed to the student? Yeah, so this is kind of an interesting thing is that if we look back here, we had a choice where hospitals get their first choice and a choice where students get their first choice. So this algorithm will favor hospitals in the sense that we're more likely to get ones like these, where hospitals get choices they like better and students get worse choices. In general, basically, if we swap the roles of hospital students, so maybe students make offers to hospitals, then in that case we'll get student preferences. So we may not really have time to prove this in this class, so you can find the textbook, but fact surprisingly, hospitals basically get their best possible option out of all stable matchings, and students will actually get their worst possible option out of all student stable matchings. So it's not really very fair. Okay, so we'll talk about why this algorithm is correct. Next time, there's some kind of interesting things about this algorithm is, again, a variation of this is used for the National Resident Matching Program, which is a real-world algorithm actually used to match students to hospitals. Now, there's some changes because hospitals take multiple students. Sometimes students want to be with couples, you know, that kind of stuff. But this is, like, again, variation that is actually used in real life for like thousands of students in hospitals. So yeah. Anyway, I'll stay for a little bit for questions, but then I have to go. There will be office hours tonight from 8 to 9 p.m. also on the Zoom link, and we'll pick this back up next time. Bye. I'll stop recording.