All right, hello everyone, welcome to the end of week two. So today we're gonna talk about graph algorithms. But before we do that, as a couple announcements, so as a reminder, homework one is due this Saturday. Homework two will also be released soon and will be due roughly at the end of next week or so. And this will be on graph algorithms, which we'll start talking about today, as well as next lecture. Additionally, so next week will be a little bit different. So just next week, I did scheduling things. I will be running a flipped classroom. So I will have the lectures pre-recorded, and then I will have extended office hours in the evening from eight to 10 p.m. on Monday and Wednesday. So that's just for next week. Again, the lectures will be pre-recorded and posted ahead of time. And then I will have much longer office hours. you can come in and ask any questions. I can go over any of the algorithms from the recorded lectures. And then after that week, week four, we'll return back to normal for the rest of the quarter. So just for next week. Okay. Before we begin, are there any questions about homework one or the content we've covered so far? All right. In that case, let me start sharing my screen. All right, cool. Okay, so today we're going to be talking about graphs. So a graph is, you can think of it simply as a bunch of dots connected by lines. So formally, we will define, so this is graphs, graph definitions. So we'll say that an undirected graph, which we'll just refer to as a graph, is G is a tuple, V, E, where V is a set of vertices or nodes, and E is a set of edges. Nodes, and E is a set of edges. each of the form u,v. So I'll draw a picture after I finish writing this down to make it more clear. U, v is our vertices. Okay, so what does this look like? So you can imagine you have a bunch of dots. So the dots here are going to be nodes. And we can give them labels. Let's say this is node 1, node 2, 3, 4, 5. And then there will be some number of lines between them, which we'll call edges. So maybe there's a line here and then a line there. So a cleaner. And then maybe a line there and say a line there. OK, so this graph, if you wanted to write this down, It's V comma E, where V is the set of vertices. So we've given the numbers, one, two, three, four, five. And E is a set of edges. So we can label the edges by the two endpoints. So for example, this edge is one comma two. This edge is one comma three. So if I write this down, the first edge is one, two. So this edge here is one comma two. The next edge is 1, 3. And then we have 2, 5, 3, 5. And those are all of the edges. They're 1, 2, 3. Do edges have directions? Good question. So here we are talking about an undirected graph, where edges do not have direction. So in particular, the edge one comma two is identical to the edge two comma one. Later on, we will introduce the notion of a directed graph where edges do have direction. And so having an edge from one to two is different from having an edge from two to one. But for now, edges don't have direction. You can write, you know, one comma two, it's either two comma one or one comma two, they're the same. Okay. So yeah, so generally speaking, when you see a graph, you'll, it's easier for us to see it drawn out like so, but we also will need a way to mathematically represent this and write this down, which will be given in this form here. So if you wanna actually write it down, kind of, and we'll show different ways to represent graphs later, but you'll do that by specifying the vertices, which generally you just give a name to each vertex, and then you'll specify the set of edges, which are just pairs of vertices, and each edge represents a line between those vertices. Okay, so this is a mathematical definition of graph, and this is the one that we'll use for this class. We will also assume that for this class, we will assume that graphs do not have self loops. Do not have self loops. So a self loop is a loop, an edge from itself. So this is a self loop. A self loop is an edge where the endpoints of the vertices are the same. Okay, all right, so why do we care about graphs? So the reason we care about graphs is because graphs are used to represent all sorts of things in real life and also in computer science, especially. So generally speaking, these are used to represent like networks. So you can imagine maybe this is an airport system where vertices here are airports and a line represent that there is an airline that will take you from say, maybe this is LA and this is New York. So you can imagine this line is like an airline take you there. And the graph will show you how you can go through the airline system to go to different cities. Additionally, you can have, say, computer networks. So you can imagine this as maybe the internet, where each of these nodes here are computers or servers, and a line represents maybe a direct connection or a way to communicate between the computers. You can also think of this as maybe social networks. So maybe this number here is a person, or each of these vertices are people, and a line represents that there is a friend relationship, for example, between them. For example, Facebook might use these to figure out who your friends are or to recommend things that your friends like. And you also see this, say, in computer science. You might have seen maybe these represent dependencies. So this is a more common one, it's a directed graph, where the edges have direction, but maybe this node here is CS31, and it's a prerequisite for CS32 and CS33, so you'll see a line between. So generally a graph is just a way to represent that there are entities, and these entities have relationships between each other, and there's lots of operations you'll want to do on these relationship structures. So this will be kind of a common way to deal with these, is just to abstract it out into the, at least the dependency format of the network. Okay, any question on the definition of a graph? Let me check the chat. All right, so as some notation that we will use pretty commonly, so if I just use n, then n will be the number of vertices. Number of vertices. And n will be the number of edges. So you'll see this also in the textbook, just it's a little easier than writing the size of the set. You just write n and m. So when I'm referring to a graph, sometimes I'll just use n and m to refer to the number of vertices and the number of edges. In general, the number of edges is going to be at most for a graph, actually, good question. Does anyone know the maximum number of edges that can occur in a graph with n nodes? Yes, so in the chat, Nemo wrote n choose two, that's correct. So I remark that n is at most n choose two, which is roughly, this is roughly n squared. But the reason why is because you can have at most one edge between every pair of nodes. So the maximum number of edges you could have is that between every two pair of nodes. So you'd have n nodes, you choose two of them, you have an edge. So n choose two as a node, this is order n squared. So roughly speaking, we'll have at most n squared-ish edges. This is actually n minus 1 over 2, but yeah, that's what we'll have. All right. So a few more definitions before we move on to what we're trying to do with graphs. So we'll define the neighbor and degree. So the neighbor of a vertex v, or the neighbors of a vertex v, is the set of all nodes connected. I'll just say the neighbor singular of a vertex v is any node u such that there is an edge u, v, and the girl. So a neighbor is just, so if you have a vertex v here, then a neighbor is simply an adjacent vertex. So a vertex for which there's an edge directly between v and u. So if I have another node over here, w, u here is a neighbor of v, but w is not a neighbor of v because it's too far away. So I can make w into a neighbor of v by adding an edge between v and w, but currently the neighbors of v's are simply the ones that are connected, or you can think of distance one exactly from the vertex v. We also have a degree of a vertex, a vertex v, and this is the number of edges connected to v. So, if I have a node here, and maybe I connect it to three other nodes, then the degree of be here is three. Okay. Additionally, we will have notions of paths and cycles. So a path is simply a way to traverse through the graph. So if we go back up here, we could imagine starting at node one, then going to node two, then five, and three. And this is a path. So a path will basically specify the sequence of vertices you hit as you kind of walk through the path. And it will be valid, you know, assuming that you can, there's edges, like you can't walk to node four because there's no way to get to node four in this graph. Okay, so a path. This is a sequence of nodes. E1 up to BK. where every consecutive pair, so bi and bi plus one of nodes is joined by an edge. An edge in G. Okay. And a simple path will be one where the vertices aren't repeated. Simple path, path where all vertices are distanced. Okay, so as an example, I guess let me, Suppose we have the following graph. I'll call this one, two, three, four, then a path, let's have a path P. I could do one, two, four, be a path, and this path P would correspond to going from one to two and then from two to four. So that's path two. All right. And this is also a simple path because we're not repeating vertices. Okay, so one thing to note is that the definition of path and what we'll come up next, which is a cycle, these tend to differ depending on the source you use. So for us, we will allow a path to-- the regular definition of path will allow to repeat nodes. It could actually double back on itself. Basically, you can just imagine a path for this class. Start a node, and you can walk wherever you want. You can double back. Doesn't matter. If you were to look on, say, Wikipedia or some other sources, they have slightly more specific definitions. So I believe Wikipedia defines a path to not allow the vertices or edges to repeat. And then they have a separate notion called a walk, which is used instead of a path and various sorts of things. But for this class, just say a path is just, you start somewhere, you follow the edges, and you end up somewhere else. And a simple path says that we're not allowed to repeat vertices, which also means you're not allowed to repeat edges, since if we were to repeat this edge, we would have to hit one of the endpoint vertices a second time. And then our next definition will be a cycle, which is simply a path where you go back around to the starting vertex. So this is a path, v1 through vk, where k is at least two, and v1 equals vk. And a simple cycle is a cycle where all vertices are distinct, except for the first and last vertex, which must be the same. First and last vertex, which are the same. Okay. And here I'll also specify that, yeah, actually this is fine here. So as an example, suppose that we had the same graph, one, two, three, four, and I could have a cycle, two, three, four, two, and that corresponds to going from two to three to four, and then back to two. So you'll see here that the first and last vertex are the same, and that's the starting and end point. Okay. And here I'll also say that there are with no repeated edges. So what this means is that it doesn't constitute to be a cycle if you go from one to two and then back to one, we do require you to take different edges. Okay. Any questions on this definition? All right, so now we have some basic graph definitions, and we want to know what can you do with graphs. So one question we might want to ask is that if I start somewhere, can I reach another node in the graph? So this is the most basic definition. Our basic kind of question is that, hey, if I'm at a node, is there even a path to another node in the graph? And this is the problem we'll be exploring for the next couple of hours. So, we define that, there again is a couple more definitions, and then we'll kind of talk about the problem we're asking. Okay, so we say that, so a distance. Oh yeah, so actually we'll talk about this afterwards. So we'll say connected. So a graph is connected if there is a path between all the vertices. So a graph G is connected if for every pair of nodes UV and the vertex set, there is a path from U to V. So as an example, this graph right here, is this graph connected or not connected? Okay, so yeah, so someone said this is connected. The reason it's connected is because if I pick any two vertices, then you can find a way to get to them. How about this graph here? Is this graph connected or not connected? Yes, so this graph is not connected. And the reason is because if, for example, I start at node one, then I cannot reach node four because in particular, there's no edges that go to node four. All right, and then we will also have the connected component of S. Of a vertex S. Which is the, this is s and all nodes are reachable from s. Okay, so what does that mean? So if I ask you what is the connect, so if I go back up here. So I say here's node one. What is the connected component of node one in this graph? So that should be node one in every node you can reach for node one. Someone said two, three, five, that's almost correct. So the connected component of one is one, two, three, five. So it's node one, the first node itself plus all the other nodes reachable from it. And we notice that four is not in the connected component of one because four is not reachable from one. Okay. And also sometimes this will refer to the induced sun graph. This term will refer to the induced sub graph. Of this set of vertices. So an induced subgraph is what you get when you also include all the edges which are part of this set. So let's go back up to here. So the connected component here is the set of one, one, two, three, five, but sometimes we will also include the edges that form this connected component. So then in that case, the connected component we might actually refer to as this entire subgraph. So for this class, we'll kind of use the vertices, but sometimes you'll see it as, you know, actually the entire subgraph that you get by, you know, following all the edges. And then finally, last couple definitions. So the distance will be how far nodes are from each other. The distance between nodes U and V is the length or the number of edges on the shortest path between U and V, or infinity if no path exists. All right, so if I were to look at this graph here, what is the distance between nodes one and four? - Two. - Two, yeah, exactly. So the distance is two because there's a path of length two. And if you look at this, you can see that there's no path shorter. There's no like path of length one. So while there are longer paths, the shortest path from node one to node four, which you can do just by trying trial and error, is just this length two. And then our last definition is going to be a tree. And a tree is a connected graph with no cycles. So the following, here's a tree because there's no cycles and you can think of that, right? There's no way to like loop back around. All right. Okay, so let me zoom out a little bit. Any questions on the graph definitions that we have so far? (keyboard clacking) Okay, so now we're gonna go into the questions of what are we gonna do with our graphs? And the first question we're gonna be asking is, One, how is a node connected to another node? And if so, how far apart are the nodes? So this will be kind of about, can you traverse the graph to reach certain things? And if so, how long does it take to reach those things? And this is kind of important, for example, maybe you need to take a bunch, maybe this is like airline system, and you would like to take the shortest path to get somewhere. Here we're not really worrying about the edge lengths, that we'll talk about later, but you would really rather not fly around in weird patterns to get to your destination, you would like to take the shortest path. And maybe for airlines, this is not too hard to do, but you can imagine you have some computer network, you have a whole bunch of different computers operating on the network, and you wanna figure out how to route your data through the fastest path to get to the other side. So this can get very complicated as the number of vertices increases and the number of edges increases. And so we want to do this a lot more efficiently. Okay, so our next session will be on graph connectivity questions. So the first question we'll call stConnectivity, which is that given a graph G and two vertices s and t, is there a path between s and t? So given a graph G and two nodes, S and V, determine if there exists a path from S to T. Okay. Secondly, we might wanna ask, well, I don't actually care, like the path is good, but I wanna know how far apart they are. So this is a little bit more specific. So we can say, given a graph G, don't just determine whether there's a path, tell me how long the path is. So given a graph G and two nodes, determine the distance from S to T. Now, note, if you solve this question, then you solve the previous question because the distance is infinity, then you know there's no path, and if the distance is anything less than infinity, then there must be a path between s and t by definition of distance. All right, and then another question we might want to ask is we might want to say, okay, I want to know the full set of things that are connected to my node. So, connected component of S, which is given a graph G and a node S, find the connected component of S. (mouse clicking) All right, so I have a graph sheet, and we'd like to find all nodes connected to this. So these are some basic questions when you're given a graph that you may want to answer. We'll talk about other questions later on, but again, the first question is, where, you know, what nodes can be reached? How far along does it take to reach them? what is the set of all things reachable from a given node. Okay. So, our first algorithm we'll talk about, but suppose I gave you a graph. So let me just draw a graph. And I gave you some node s and some node t. And I said, imagine it. So here, all right, if you're looking at this, is s connected to t? Is there a path from s to t? Yeah, so some people are saying yes, there is a path from ST, and that's correct. You can kind of see here, here's a path from ST, there's a couple of different ones. But while it's easy for us to kind of visually look at this and what the answer is. Computers don't really, currently, don't really have that type of processing. So maybe actually AI can do stuff like this on simple graphs, but in general this is not really something a computer can process very easily. A computer would like to not, you know, try to visually look at a graph, which again, this may be huge. So here, our graph we can kind of visually easily represent, but you can imagine one where you have a million nodes and you're which things are connected or where. So as this problem scales up, this becomes a lot more difficult to see visually, and we would like to do this at a much more local level. So by local I mean I don't want to have to look at the entire graph at once, I only want to look at small portions of the graph at a time. So the way you can imagine this, if you're trying to think, you know, how would you solve this, imagine that you, this is a maze, and these are corridors, and you've you've been dropped into S and you have like a flashlight. And each of these nodes maybe have labels and you would like to wander around your maze and figure out how to get to T. So what you're allowed to do, maybe add another node just for good measure, is you start at S, you can see that there's two corridors leading up and you can, you know, wander down a corridor, figure out the name of this vertex and then you'll see more corridors leading off and you can wander around trying to find T. Okay, so if I dropped you into the middle of the maze, and I said, there's a location in the maze called T maybe, what's a strategy you might use to not just wander aimlessly around the maze? Because if you wander aimlessly, it's possible you just go in circles forever, which would be bad, because we don't want our algorithm to run forever. any ideas on strategies? - We can check if we already traversed that vertices. - Okay, yeah. - So there's second time. - Yeah, that's a great point. So if we start at S, what we don't wanna do is we don't wanna backtrack a lot. So we would like to say, okay, if I've already visited this verge, maybe I'll put a mark on the wall I've already been there so that I don't go back again. And at least what that will do is that, if you reach something, you've already been there, you can turn back and not do it. Yeah, someone in the chat talked about depth first search. Well, let's come with those terms a little bit later, but that is a way to do it. So, yeah, so kind of an important note that was made is that we wanna keep track of things we've already visited to not do that again. And the way that we're going to do searching is we're going to do, we're going to start with breadth first search, which you go kind of outward in waves. So you start at node S, and then you look at everything close by the S. So you go down this corridor, say, is that T? Nope. Come back, go down this corridor, say, is that T? Nope. You come back. And then once you've searched everything right next to S, then you'll search things one farther away. and you're kind of expanding outward, you can imagine that you put maybe like a water pump at S and you start pumping water into the corridors and wherever the water reaches first, the nearby ones are where you're gonna visit first and then wherever the water reaches next is the next set of things you'll visit. So I'll kind of write this down with intuition. So this will be called, let's call it a breadth-first search. breadth-first search, or a BFS. So the idea of the breadth-first search is that you're going to expand outward from S, in all possible directions, adding nodes one layer at a time. Okay, so let me just copy this diagram here. Down below. So you can imagine that first you start with s. So we'll call this L0. your starting node, and then you'll look at everything that's directly next to S. So we'll expand our search out a bit more. Let me give these nodes names. We'll call this u, v, w, x. And our next layer is going to be stuff next to S. So we'll call this layer 1. Will be u, v. And then next we'll look at everything that's, you know, one more away from this. So that will be W and T, like so. And now we're done because we found T. But you can imagine doing this one more step where you're gonna expand it again, and that will get you to X. So layer three here will be X. So in a BFS, again, you should think about, you know, you put a water pump at S, you start pumping the corridors for water, and then what happens is that, you know, the water expands to the nearby rooms first, and that's where you're going to search first. And once you've searched there, then you'll keep expanding out from where you left off and get to new nodes there, and then you'll keep expanding off and get to other nodes. So this is how breadth-first search is going to work. Start close by, go farther out. So I'll just kind of define layers. So L0 is node S. L1 is the neighbors of S. So if we dot dot dot, this will be the nodes. Which are neighbors of some node. In layer, the previous layer, layer li. that are not already in some previous layer. So what does that mean? Right, so when we went, so we started with L0, which is S, and then we looked at the neighbors S, which are U and V. And then to get our next layer, we're gonna look at the neighbors of U and V, which are S, W, and T, but we're not including S because we've already included S in the previous layer. That's why we get only W and T. And then we'll look at the neighbors of WT, which are U, V, and X. And because U and V are already in previous layer, we're not gonna include them. So we'll just include X here. So that's how we're gonna expand out. Again, we start with an S, we go to neighbors of S, we go to the neighbors of neighbors of S, and the neighbors of neighbors of neighbors of S, and so on and so forth. And as was previously noted, we don't wanna backtrack. So if you've already hit a node, you're not gonna include it Okay. questions on the intuition behind breadth-first search? All right. So now I'm going to write down kind of a general form algorithm. What this algorithm will do is kind of fully explore the connected component s. So you can use this algorithm to answer, basically, each of the three questions we had before, which we'll show how to do. But this general form will not specifically answer the questions. it will just explain the process of exploration. So if I'm exploring outward in this way, then I can notice that at some point, if I'm trying to figure out if I can reach T, well, if I hit T, then I can reach T. But the process we're describing is this exploration process, including basically hitting all nodes that's nodes that you can hit in the graph. So here's the algorithm. So we run BFS on a graph G, which would be E, and node S, where S is a node in G. And all we're going to do is just what I described right here. We're going to start with a layer, and one by one, we'll add new layers. So L0 will define to be S. And then we mark s as discovered. So again, this is what was mentioned earlier, we don't want to backtrap, so if we've already seen the node, we're going to remember that we've discovered it. That is at the high level algorithm, by the way. We haven't talked about how to implement this. And now we're going to, one by one, go through the new layers. We'll set i to be zero, which means that we're in level L0. And then we're going to go through layers one at a time. So while the previous layer, Li, is non-empty, so as long as we're still finding new nodes to explore, we're going to set Li+1 to be the empty set. I'll let this empty set. And then for each node in the previous layer, we're going to go look at all of its neighbors. And if that neighbor has not been discovered yet, we're going to add it to our set. So we'll consider each edge UV incident to U. Incident just means that the edge is touching node U. And if v has not yet been discovered, discovered, then we'll add v to li plus one and mark v as discovered. And then lastly, we'll increment. All right. Let's give these a b c. All right, so you see here this is not returning anything, because again, this is just describing the exploration process. So what is happening? We're starting with the node s, which we marked as discovered. And then we're going to go through and we'll look at all the neighbors of the nodes in the previous layer. And if they have not yet been discovered, we'll add them to the next layer. And then we'll finish once we reach a case where we're no longer-- we didn't find any new nodes to add. So this non-empty part, again, that's what is it saying? What is that eventually at some point, if we stop being able to add nodes, then our next layer will end up empty, which means that when we go back to the while loop, we'll say, OK, nothing new happened. We're done. we're going to stop. So let me show an example of how this will work. Actually, before I do that, any questions on how the algorithm works? All right, so yeah, let's do an example just to be very concrete. So let me draw some sort of graph. Okay. And let's say we run BFS on S here. And I'll just give these other nodes numbers. So layer zero will have s and then we'll have discovered over here. Okay, so we start off by we set layer zero to be S and we mark S as discovered. So S is here. Okay, so put a little check mark by S. Yeah, okay, so what should be in layer one? - One and five. - One and five, yeah, exactly. So these are the neighbors of S. So how did we find it? We went to S, we said, what's next to S? And we said, oh, one in five right there. So now we add one in five to discovered. And now we have them all. All right, so maybe I will start marking these off. Different colors. Okay, what should be in layer two? - Four, six. - Four, six, yeah, exactly. So what we see is that the neighbors of one and five are S, four and six, but we've already discovered S, so we don't care to add it again. So our next layer here will be four and six, and so we'll mark those ones also as discovered. All right, what about layer three? - Three. >> That's right, yeah. So again, we just go find some new nodes we haven't touched yet. Over here, we're going to add this to discovered, S15463. Layer four, so I'll just finish this off. This will be two and seven, which are the next nodes here. S1, 5, 4, 6, 3, 2, 7. And then we'll have layer colors. Okay, we'll use yellow again. Layer 5 will be 8. 5, 4, 6, 3, 2, 7, 8. All right, and then what should layer 6 be? >> Empty? >> Empty, yeah. So we went and looked at all the neighbors of eight. And there were no neighbors of eight that are not already marked. So our next layer is empty. And discover it's still the same. And that's how we know to stop, is because we've reached an empty set, where nothing has changed. Okay, so that's how the algorithm works. All right, so one question here. If you're looking at this graph here, and I were to ask something about, so first of all, we're going to prove some things, which is one that BFS, if a node is connected to S, then we will find a path to it. But second, there's kind of something you can realize about the distances. So what is the distance between S and node 3? Remember the distance at the length of the shortest path, which is the number of edges between S and 3. OK, 3. And we see that 3 is in layer 3. What about the distance from S to 6? 2. It's in L2. 2. It's in L2. Yeah. So we actually noticed something pretty interesting, which is that the distance from s to any node is also equal to the level that that node can be bounded. And this way we'll formalize. So let me just write this down. So observe that the distance from s to t is equal to the number of the layer that T is in. And in particular, a node S has distance 0 to itself. So that also works out. So we can kind of see, without doing any proofs yet, that it feels like we're exploring everything that's connected. another node over here outside, then that node would not be included, right, because once we reach h, there's no more neighbors of 8, so 9 will be not included, so we haven't encountered node 9. So one, it seems like it can help us find the connectivity problems, and two, it also feels like it can help us find the distance, because as we seem to observe, it seems that the layer number also specifies how far s is from those nodes. And this will, these intuitions will be exactly right and now all we have to do is prove that these things are true. Okay, but yeah, so we're going to take a quick break until say 11.05 or so, but are there any questions on how this algorithm, at least the kind of loose high-level version, operates. I have a question. When we are traversing and we are, for example, level three and we want to go to level four, find all the members of level four, do we only check if we have duplicates in level three or before all the levels too? Oh yeah, good question. Yeah, so when we're checking If it's a duplicate, we check if it's a duplicate anywhere. So we notice that our discover set also includes all the nodes from all the previous sets. So when we determine whether or not to add it, we only add it if it hasn't been discovered at all. So not just from the-- so if, for example, there was somehow a couple of edges from 3 back to s over here, OK, it would be an earlier layer, but-- There was my question. So would it be possible? So we get neighbors to the initial layer three. It's not one. Right now, if we are on level three and we want to go to level four, we would find all the neighbors are going to be five. And now all the neighbors are going to be 4, 2, 7. Yes? And the 4 is in a previous level. So we don't need to go into level 1 and level 0 to check if we find it. Is it sufficient to go one layer back and check for duplicates? Yeah, OK, so this is a good point that we'll talk about. So in it, yeah, so it won't, let's see. So what you'll kind of find is that the exploration path, the edges will only kind of like, so if you imagine, we'll talk about this later, that you had an edge between the vertices when you found that path, then the edges will only be between adjacent nodes in the path. And in fact, the kind of backtracking you might expect couldn't happen. So for example, what would happen, let's say, if s was connected to 3? And you're like, oh, s was in such a far back level, I had to check for its neighbors. Well, if there was actually a link between s and 3, 3 really should have been discovered earlier. So it is kind of sufficient, really, to just check the most recent discovered things. - Efficiency, like we can only check last layer. That's what the question like. - Yeah, yeah, yeah. - Make it more efficient by just checking last layer. - Yeah, you could do that. And then let's see, there's another question. Is this an assumption or is that a point where it splits into two separate paths? Like four has its own branches and six has its own branches. I may have missed what to consider. So okay, so imagine, or, so you could imagine maybe four and six have an edge here, in which case it wouldn't matter which one three is including it. So we haven't again talked about exactly how to implement this, but as long as three was connected to one of either four or six, then it should be in the next layer. But it doesn't matter if there's a connection, like both four and six connected threes, okay. Maybe the particular graph I drew is not the most general. I'm not sure if I, yeah, but this works for all kind of graphs as long as there's not multi edges, which is multiple edges between the nodes. And actually it still would work for that. And we're assuming there's no self loops and no multi edges. But there doesn't need to be a specific structure in this graph. - I had a quick question. - Yeah. - So you mentioned like if you had a edge from S2, 3, and so in the layer basically two, in the layer one we would discover, like in L1 we would discover S1, 5, and 3, right? - Yeah. - So when we would get to the L3, then we wouldn't like do anything, right? Okay, so what would happen? So let's just draw this out. So imagine there is an edge from S to 3. So layer 0 would be S, layer 1 would be 1, 5, and 3. Layer 2 would now be 4, 6, 3, and 2, and 7. So because 3 is now in layer 1, then layer 2 expands to also include 2 and 7. And then layer 3 would be node 8, and then we would finish. So kind of the whole structure changes a little bit. Oh, OK. So we won't consider the three anymore. But I didn't understand why we consider the two. Like, I got the four, six, but the two, I don't understand why we get that. Oh, actually-- oh, yeah, I got it, actually. No, no, no. OK, cool. Yeah, so yeah, the reason why we consider two and seven for other people listening is that if three is in layer one, then we have to include the neighbors of everything in layer one, which would also include three and two and seven. >> Yeah. Got it. Thank you. >> Okay. Good questions. A lot of the things, sometimes when you're looking at these new algorithms, a really good way to figure out if you've understood this, is to actually just draw a graph or an example of the problem, and then try running it yourself and see if you know what's happening. And if at any point you're like, oh, wait, actually what does happen in this case, that's where you can kind of go back and look at the algorithm and you'll find the holes in your understanding that way. So I highly, highly recommend, and this isn't true also if you don't know what the algorithm is. So if you're just giving it the problem and you wanna figure out how should I think about the algorithm, you can start by just drawing out kind of smaller instances of the problem and then trying for yourself to sort of notice any properties or like, you know, how would you do this? Like in real life. Okay, so at this point I'm gonna pause the recording and we'll have a break until 11.10. And then we'll come back and we'll prove some stuff about this and then talk about how to implement it. And then next week, again, there will be the pre-recorded lectures and those will be, we'll talk about, more about graph algorithms. But yeah. Okay, so now we have this kind of search algorithm, and I'm going to prove this observation down here, which is kind of the most important part. And once we prove this, then we can kind of see how we can answer all of our connectivity problems or like the questions we were asking based on this observation. So let's prove this. So here is our lemma. So we'll say for each j, at least zero, layer lj produced by BFS GS contains all nodes, or consists of, All nodes at distance exactly j from s. Exactly j from s. Alright, and this is what we saw here, right? Layer 2 consists of the two nodes which are at distance 2 from s. Therefore, it consists of the two nodes which are distance 4 from s, and then there are no nodes distance 6 from s. And the way we're going to prove this is by using induction. So what happens in inductive proof? So we notice here that we want to prove this for a sequence of statements, one after the starting with j equals zero, then j equals one, j equals two, and so on and so forth. And what we can do is we can say, okay, suppose we're gonna prove it's true for the base case, j equals zero. And then we're gonna say, suppose it was true for the previous cases, prove that it's true for the next case. So that's how induction holds. And yeah, let's, so this will be proof by induction. Okay, by induction on J. So induction will be also another important proof technique in addition to proof by contradiction that we'll be using in this class. Okay, so for induction, you have the base case, which is the smallest case you're considering. In this case, the base case is J equals zero. All right, so remember that we're dealing with L zero. So can anyone tell me why this statement is true specifically for layer L zero, which is the base case? If people remember what L zero is. Let's see, Owen said the distance to itself is zero. Yeah, okay, so basically what happens from layer L0? Well, layer L0 consists just of s, and they only know this distance zero from s is itself. So that's why this will be true. So we can say that, by BFS sets L0 to be S, and S is the only node distance zero from S, or which is distance zero. And this is just by definition of distance. How do you start from S and using no edges? So what does distance mean? Distance means that you start from there, from S, and using the distance number of edges, you can reach another node. So if I start from S and I use zero edges, the only place I could possibly be is S. So by definition of distance, then this is correct here. Okay. Any questions on the base case? Okay. So now we're going to use prove with inductive. So what's the inductive step? we're going to suppose that the statement is true for some j, and then we'll prove this true for j plus one. So, actually I'll use strong induction case, which means that I'm proving it true for all statements at most some value. Okay, so we'll say assume the statement holds for all j between one and k, for some k. Then we will show the statement holds for j equals k plus one. Okay, so what we're doing is we're saying, suppose we've already proved it for everything up to some point k. Now let's show that it holds for the next layer, k plus one. And this is kind of what your inductive proof will look like in general. You'll say, assume the statement holds for what you've done previously. Now show it holds for the next part of the proof. Okay. All right, so what do we need to prove? So we need to prove kind of a couple things. So first we need to say that, we wanna say that layer lj is exactly the set of nodes at distance j from s. So you kind of think of this two ways. So first we want to say that if I know it's in layer LJ, then it's exactly J from S. And if I know it is a distance J from S, it's exactly layer LJ. So to kind of break this down, we want to show two things. So first we're going to show If v is an lj, then v is distance, sorry, lk+1. Then v is distance k+1 from s. And then we're gonna also wanna show down the line, we'll do this later. If v is distance k+1 from s, then v is in L k plus one. All right, so why are there kind of two things to show here? Is what we're trying to do is show setting quality. We're trying to say the set of nodes in L k plus one is equal to this other set, where the other set is all the nodes distance k plus one from s. And one way to show set equality is by saying, well, if something's in the first set, then it's in the second set. And if something's in the second set, is also in the first set. So to show that these sets are exactly equal, which again is LK plus one, and then the nodes, they're distance K plus one from S, we want to show that kind of a node is in the first set if and only it's in the second set, which kind of implies two directions, right? If it's in the first set, then it's in the second set, and if it's in the second set, then it's in the first set. So that's how we're breaking down this proof. Okay, any questions so far? Okay, so. Okay, so let's just start, actually the second one's a little bit, I will start with the first one. Okay, so any ideas why this should be a good idea? be true. So let's say a node appears, right? So let's say we have node 3. It appears on layer 3, and we know that layer 0 through 2 are correct in the terms of these are exactly distance 2, exactly distance 1, exactly distance 0. Any ideas why 3 should be exactly distance 3? Or like how do we prove this statement? Any ideas? From layer k to k plus 1 is one step, so it's an additional one step, something like that? Yeah, exactly. So basically how did we get to node 3? Well, we went from layer 2 and we took one step. And we know that these are distance 2, so if this is 2, there's a path of length 2 to that node. And then we take one additional step to get to node 3, and that's how we get a path element. So that's kind of exactly what we're going to write down. Okay. So we can say by definition of LK plus 1, V is in LK plus 1 if there is an edge from sum u and lk to v. Okay. Well, by induction, we've said that the statement is true for all. Okay, that means, uh, I pop. Pop it Then u is distance exactly k from s. I'll move this down. Okay, this will be happening much later, so let me just kind of move it to the side for now. Come back to that. Alright, so this means that there is a path. We'll call it P of length k from s to u. This is just by definition of distance. Um, if we add. V2 Then we get. P prime, let's say. Distillate one. To be so OK, so what's happening here? So we've said that. We have S. We have you. We have V. All right, u is in layer LK, u is in layer LK plus one. And because u is in layer LK, we know that there's some path here, P. This is length K. And so then that means that there's a path all the way to V. So P prime is this whole path here. which is length k+1. So we took our path to P, to U, which we know exists because U is an LK, and then we added one more edge which gives a path of length k+1. All right, and then what does this mean? This means that the distance from s to v is at most k+1. Why is it most k+1? Well, there is a path from s to v, So of length k+1, so the shortest path, right, has to be at least k+1 or maybe smaller. So the shortest path, p' might not be the shortest path, but there is at least a path of length k+1, so the distance can't be more than k+1. And now we want to argue that the distance is not less than k+1. Okay, so what did we said so far? again, we said in order for it to be an LK plus one, it must be connected to some node in LK. And if U is in LK by our induction hypothesis, that means that U is distance K from S. So there's a path of length K to U. If we add this extra edge from U to V, that means we get a path of length K plus one. So V is no more than K plus one away from S, K plus one edges. All right. So now that we've said this, why is V, why is there not a shorter path for V? If there was, if it was shorter, then it should be like K or less, but we said like we discovered all the paths, all the vertices that are K or less, and V was not there. Perfect. Yeah. So that's exactly the answer. So the reason why it's k plus one is the shortest distance was that if there was a shorter path, then V would have ended up in one of the previous layers because by our induction hypothesis, the previous layers consists of all the nodes who are at shorter distances away. So we can write this down. We can say, yeah, suppose, that there was a shorter path, we'll call it p double prime, from s to v, of length t less than k plus 1. Then, by induction hypothesis, v would be in a previous layer. Okay, so yeah, so suppose there was a shorter path. Would it be in the previous layer, which is layer lt or smaller? So yes, maybe that'll be more specific. So we'll just say, I'll change this to be slightly more specific to make the argument a little more clear. We'll say, now let p* be the shortest path from s to v. If P* were of length t less than k plus 1, then V would be in layer L(t) by inductive hypothesis. So B would already have been discovered. Already have been discovered. Discovered and would not be added. Okay, let's wait. So thus the distance from S to V is k+1. Okay, so let me just explain what I wrote, is that we said, okay, the distance is at most k+1, and we said, well, suppose that it was shorter. Well, if it was shorter, we've already determined the set of all vertices, right? They're distance exactly up to K from S and V was not yet discovered. So if the shorter path did exist, then V already should have been in one of those previous layers and should have been marked discovered, but it wasn't marked discovered because the only reason we add it to LK plus one is that we haven't previously discovered it. So that's what we're saying here. You could write this maybe using less words, but that's kind of how you show this. So you can also think of this as like a miniature proof by contradiction, but within our inductive proof. But again, all we're saying is that, well, how did we get to LK plus one? We took one edge from LK, so we can just add one to the path and V should not have been in a previous layer. Like V should not be closer to S because otherwise V would be in a previous layer and then would not have been freshly discovered. So that's the argument. Okay, so a little bit complicated. Any questions on this argument? Okay. So now we just need to prove this other statement here. Let me clean this up a little bit. Okay, plus one. Okay, now I wanna prove that if b is distance k plus one from s, then b is gonna be in this layer. Okay, plus one. Any ideas why this will be true? There's a note when you're stuck with, when you're kind of not sure where to go, it's helpful just to go look into a definition of a distance, right? What does it mean if v is distance k plus 1 for s? >> The shortest path is k plus 1. >> Yeah, so we'll just start with that and then we'll see where we go. So if v is distance k plus 1 from s, then there is a path. We'll call it P, and we'll give it S, and then some nodes, and eventually we'll end up with U and V. From S to V of length k+1. So pictorially, what's happening? So we have S, and we have V, and I'm saying that there is a path here. call this p, and this is length k plus 1. And I'm also giving a name to the node right at the end of the path. So this node here, this is u. And u is the node directly before v on path p. Okay, so all I know is that there is some path P which is length k + 1 and u is the path node directly on the path before. All right, any ideas now that we have this diagram? So we should show that u is a k length from s? Exactly, yeah. So if we can show u is length k from s, that means that u should be in Lk, and then that means v should have been discovered in Lk plus one. So that's exactly what we're going to show. So we'll say we know there is a path, we'll call it p prime, from s to u of length k. This is just path p minus the last vertex. So u is distance at most k from s. All right, and why is u not at distance less than k from s? So yeah, so if we take this path and we cut out v, then we get a length k path. So u is, you know, at most distance k from s. But why is u not closer to s? If it was closer than k, then v is going to be the next one. So we would have been lower than, closer than k plus 1. But we know it's k plus 1. Yeah, exactly. So if you were closer, then v would also have to be closer. Basically, right, if there's a separate path to u, there's a shortcut to u, then v can also take the shortcut and be closer to S. So let me just write that. So, this, there is no shorter path from S to U, since otherwise, there would be also be a shorter path To v, meaning v would not be distance k. K plus one from s. So let me just kind of draw this out. So we have, let's copy this down. Okay, so let's delete this here. Okay, so suppose that there is a shorter path, a shortcut, right? This would imply v is closer to s also. All right. So what does this mean? This means that u is exactly distance k from s, which means u is in Lk. And that means that v will be discoverable from u and will end up in Lk plus one. So let me just finish off the rest of the argument. So we say, thus, U is distance K from S, which means U and LK by inductive hypothesis. by inductive hypothesis. Therefore, since V is an undiscovered neighbor of U, we will add V to L cables. All right, so what did we say? We just said, well, u, because it's an LK, what do we add to LK plus one? We add all the neighbors of u to LK plus one. So we're gonna add v, and v is previously undiscovered because the only thing we previously governed are things that are smaller distances. So that's how that part of the proof works. Okay, let me zoom out a little bit. So yeah, to summarize this argument, we said there is a distance k plus one path, and the guy right before us on the path also must be distance k, otherwise we'd have a shortcut, which would mean a shorter path to v. So because he's at distance k, he must exactly be in Lk, and that means that we will discover v when we go look for Lk plus one. the gist of the argument. I wrote it in more words. Your proofs did not necessarily have to be as lengthy as this proof. I was just trying to do it for better explanation. Yeah, so someone asked about the induction hypothesis. So where the induction hypothesis get used? Induction hypothesis got used because we said that u was in LK because distance K from S. So we've said that for LK and smaller, then these are exactly the nodes distance K from S. And then also, I guess I didn't really write this down, but why is B undiscovered? It's undiscovered because we know that the previous layers have to be things that closer distances away. Any other questions on this proof? I know it's a complicated proof. It's good to kind of go home and stare at this some more. Is it trivial that u cannot be more than k distance away? Like, if it was shorter than k, did we prove that more than k cannot be? Oh, so the distance is the length of the shortest path. So first we showed that there exists a path of length k to u. And so if the distance was larger than k, right, so the distance is the shortest path. So we know that this path from s to u of length k, it could be the shortest path, there could be shorter paths, we're not sure yet, but certainly there's, you know, the distance can't be more than k because we already have a path of length k. - Okay, got it. - Yeah. So yeah, the first part was to say that distance is at most k, and then the second part was to say if the distance was less than k, well then v should also have had distance less than k as well. I'll just say that this can't happen. the distance k plus one from s. Okay. - How do you know that v is an undiscovered neighbor of u? - Okay, yeah, so I didn't quite write that down. So, let me just write this down. Okay. By our induction hypothesis, V is not in layers L0 through Lk. So V has been... Yeah, so by induction bias, V is not on layers L0 through Lk because V is distance k+1. k+1 from S. And that means that V has not been discovered yet, which implies that it's undiscovered in the next step. So remember our induction hypothesis said that all the previous layers were correct. And if the previous layers are correct, then they should only contain things of distance k or less. So it'd be as distance k goes to 1. Good question. Okay. Any more questions on this proof? All right, so let's just kind of talk about implications. So we've now proved our observation, right? That every layer produces things exactly distance J from S. And another thing that we can prove is that basically the number of iterations of the while loop won't be too large. So in particular, I'm gonna prove the following. So lemma BFS will end in at most n iterations of the while loop. So I claim that, in other words, i.e. l sub n will be empty if we get there. Sorry, so what is n? N is the number of vertices. Okay. So I claim that layer n, where n is the number of vertices, will be empty in our graph. So any ideas why that should be true given our previous one? >> Because if we are not terminating, we are adding at least one element. So if we keep adding just one, it's going to be like n times. >> Yeah, okay, so that's actually a different proof, and that's also entirely correct. So I'll explain the different proof first, and then I'll explain another proof for it. So what was just said was that we only continue if we can add a node. And then most number of nodes we can add is all the nodes. So if we start at layer zero, then if we add one node each time, then we'll run out of nodes after layer n minus one. So layer n will be empty. So that's completely correct. That is a valid proof. I'll explain this a little bit more in a more kind of overall sense that by our previous lemma, and this is also mentioned in the comments, the layers that consist of all nodes at distance exactly j from s. And in fact, if a graph has n nodes, then the maximum distance you could have is n minus one. Because once you, basically if you want to look at the shortest path and you don't want to repeat nodes, like if you don't do cycles, then the worst cases that you go through through all nodes exactly once and then reach the final node. So let me write this down. So we'll say that by a previous lemma, Ln will consist of all nodes get distance n from s. And then we'll say, however, no node can have distance n or larger from s, Since that would imply that the shortest path has n edges. So n edges, and then this which means that the path repeats a node. A node. So if you have more than n edges, then you have to have at least n plus one nodes. So you can imagine, okay, you have S, and then you go to B1 and then B2, and so on up to Bn. And S plus these n nodes, mean that there's a repetition in the path. And if there's a repetition, the path of a cycle. And then you can find a shorter path by getting rid of that cycle. Okay, but you could delete the part of the path between the repeated nodes. To get a shorter path. From s to the node. So in other words, if you had some path from s to say, I don't know, t, where there's a repeated node. then you can always just delete the cycle that you find to get a shorter path. So therefore it can't be the shortest path. So the shortest path from S to any node can contain at most each node once, because otherwise you'd have a cycle and the cycle means you can delete the cycle and get a shorter path. Thus the longest distance from any node to S is at most N minus one, and therefore layer N will be empty. Okay, so one last thing before we go is I'm going to just talk about very briefly how to do the three questions we asked at the beginning. So here are our questions. And given BFS, and sorry if that was a little brief, I'll put it up afterwards, but how do we solve each of these three questions using BFS? So I have my BFS algorithm, and I want to say, how do you determine if there's a path from S to T. - We can start with the first algorithm to see if we end up having the T in our set. - Yeah, so we'll run BFS GS. And output yes if we encounter t. And no else. Because if we don't, we know that BFS will terminate. And if we don't encounter it, that means this distance must have been infinity. All right, how do we find its exact distance? Or over layer it ends up that's the distance. Yeah. It doesn't end up in a layer that there is no path. And output the layer number where we encounter the-- and we'll output in Vandy otherwise, which is the distance if they're not connected. Otherwise, okay, that's a bad identity. Lastly, how do we find the connecting component of S? >> All the vertices in the set, in all the layer, we find? you run BFS GDS and output all nodes encountered or discovered. So as we can see, BFS and what we'll cover next, which will be DFS, allow you to kind of answer all these questions and more. There are some other examples you can see in the textbook for bipartiteness. And, yeah, so next lecture, we'll talk about the complexity analysis for this, and then DFS and topological sort. As a reminder, like I mentioned at the beginning of the class, next week, just only next week, will be a little bit different, that the lectures will be pre-recorded and there will be extended two-hour flipped classroom office hours from 8 to 10 p.m. and then it will return back to normal the following week. So at this point, I'm going to end the recording, and office hours will be now until 1 p.m.